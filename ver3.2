import random
import math
import csv
import time

# TODO mmr

modes = """
Bilkent LoL E-Sport Team Finder by Can Gürsu and Yunus Özkan!

-This program is created for players to find teams. There are 7 modes to this script:
Mode 1: Primary Roles, NO Secondary Roles, NO Auto-Fills, and NO Rank Consideration. (start p)
Mode 2: Primary Roles, NO Secondary Roles,    Auto-Fills, and NO Rank Consideration. (start pa)
Mode 3: Primary Roles,    Secondary Roles, NO Auto-Fills, and NO Rank Consideration. (start ps)
Mode 4: Primary Roles,    Secondary Roles,    Auto-Fills, and NO Rank Consideration. (start psa)
Mode 5: Primary Roles, NO Secondary Roles, NO Auto-Fills, and    Rank Consideration. (start pr)
Mode 6: Primary Roles,    Secondary Roles, NO Auto-Fills, and    Rank Consideration. (start psr)
Mode 7: Primary Roles,    Secondary Roles,    Auto-Fills, and    Rank Consideration. (start psar)
-User can use a formatted text file to create teams, or choose a csv file to convert to 
a formatted text file.
-User can see the raw or numbered versions of the formatted text file, or Users can search 
by keywords to find mail, nick, fullname, primary and secondary roles of players.
-User can manually add or delete player data.
"""

menu = """
Bilkent LoL E-Sport Team Finder by Can Gürsu and Yunus Özkan!

Command List:
-Type 'menu' to bring this command menu.
-Type 'modes' to bring the modes menu.

-Type 'txt' to change/create the text file. Only enter the name of the file, 
not the (.) extension. Ex: not 'players.txt' --> 'players'
-Type 'csv' to select a csv file to use its data. The program will ask to 
create a new text file or add data to existing text file. Only enter the name of the file, 
not the (.) extension. Ex: not 'tourney_input.csv' --> 'tourney_input'

-Type 'see' to see raw text file for all player roles/names.
-Type 'number' to see numbered version of text file for all player roles/names.
-Type 'bilkent number' to see numbered version of text file for players that have Bilkent Mail.
-Type 'mail' to enter keywords to look for player mail. 
-Type 'nick' to enter keywords to look for player nick.
-Type 'fullname' to enter keywords to look for player fullname.
-Type 'primary' to look for players by primary role.
-Type 'secondary' to look for players by secondary role.

-Type 'add' to enter additional players to the player list. Type the player roles and names.
Input Formatting: (Mail,Nick,Fullname,Rank,Primary,Secondary)
-Type 'stop' to exit from player inputting.
-Type 'del' to delete players using the 'number' command and typing their number. --> Ex: '4 16 7' 

-Type 'quit' to save data and exit from program. Program might not work properly if it is not 
exited this way.
"""

add_info = """
Input Format: Mail,Nick,Name_Surname,Rank,Primary,Secondary
Mail has to have '@ug.bilkent.edu.tr' in it.
Players cannot have same email.
Roles have to be either 'Top' or 'Jg' or 'Mid' or 'Adc' or 'Sup'.
"""

deleted_info = """
-Type 'start' to create teams. Players are put only on their primary roles. 
NO Secondary Roles, NO Auto-Fills, NO Rank Consideration.

-Type 'start autofill' to create teams. Maximum number of players are put on their primary roles, 
left over players are auto-filled randomly. 
NO Secondary Roles, Random Auto-Fills, NO Rank Consideration.

-Type 'start ranked' to create ranked teams. Players are put only on their primary roles. Enter a tolerance
to determine a rank gap. Lower the tolerance, closer the total team ranks will be/harder for the program to create
teams if number of competitors is small.
NO Secondary Roles, NO Auto-Fills, Rank Consideration.
"""


def raw_print(txt_file):
    """
    Take some .txt file and print the players in it.
    """
    result = ""
    with open(txt_file, "r") as file_handler:
        for line_el in file_handler:
            if line_el != "\n":
                result += "{}\n".format(line_el.strip())

    return result


def numbered_print(txt_file):
    """
    Take some .txt file and print the players with numbers next to them.
    """
    result = ""
    with open(txt_file, "r") as file_handler:
        for start_num, el in enumerate(file_handler.readlines(), 1):
            if el != "\n":
                el = el.strip()
                result += "{} {}\n".format(start_num, el)
    return result


def bilkent_numbered_print(txt_file):
    """
    Take some .txt file and print the players that have Bilkent mails with numbers.
    """
    result = ""
    correct_num = 0
    with open(txt_file, "r") as file_handler:
        for start_num, el in enumerate(file_handler.readlines(), 1):
            if el != "\n" and "@ug.bilkent.edu.tr" in el:
                el = el.strip()
                result += "{} {}\n".format(start_num - correct_num, el)
            else:
                correct_num += 1
    return result


def does_file_exist(some_file):
    """
    Look if the file exists, if it does not exist create one.
    """
    try:
        some_data = open(some_file, "r")
        some_data.close()
    except FileNotFoundError:
        print("{} was not found!".format(some_file))
        some_data = open(some_file, "w")
        some_data.close()
        return False
    else:
        return True


def convert_to_type_fullname(file_type):
    """
    Take some file name, if the file exists make it name.txt or name.csv
    """
    full_name, usr_inp_txt, usr_inp_csv = "", "", ""
    does_exist = False
    while not does_exist:
        if file_type == "txt":
            usr_inp_txt = input("Enter text file name to look player data from!(Ex: 'players'): ")
            full_name = str(usr_inp_txt) + ".txt"
            if does_file_exist(full_name):
                print("'{}' will be opened and used.\n".format(full_name))
                does_exist = True
            else:
                print("'{}' will be created and used.\n".format(full_name))
                does_exist = True

        elif file_type == "csv":
            usr_inp_csv = input("Enter a csv file to read roles/nicknames from!(Ex: 'tourney5docs'): ")
            full_name = str(usr_inp_csv) + ".csv"
            if does_file_exist(full_name):
                print("'{}' will be opened and its information used.\n".format(full_name))
                does_exist = True

    return full_name


def convert_csv_to_txt(mode):
    """
    Take a csv file name, convert it to name.csv
    Open that csv file and add its content to a txt file.
    During the process, create a new txt file or add to an existing one.
    """
    csv_full_file_name = convert_to_type_fullname("csv")

    usr_inp_txt = input("Enter a text file name to transfer player data from csv file!(Ex: 'tourney5docs'): ")
    full_name = str(usr_inp_txt) + ".txt"
    print("'{}' will be opened!\n".format(full_name))

    result = ""
    with open(csv_full_file_name, "r") as csv_file_player_data:
        csv_file_reader = csv.reader(csv_file_player_data)
        next(csv_file_reader)

        with open(full_name, mode) as output_text:
            csv_counter = 1  # 1=Mail, 2=Nick, 3=Name Surname, 4=Rank, 5=Primary, 6=Secondary
            for line_el in csv_file_reader:
                if line_el:
                    line_el[csv_counter] = line_el[csv_counter].replace(" ", "_")  # Mail

                    line_el[csv_counter + 1] = line_el[csv_counter + 1].replace(" ", "_")  # Nick

                    line_el[csv_counter + 2] = line_el[csv_counter + 2].replace(" ", "_")  # Name Surname

                    player_info = (line_el[csv_counter] + "," + line_el[csv_counter + 1] + "," +
                                   line_el[csv_counter + 2] + "," + line_el[csv_counter + 3] + "," +
                                   line_el[csv_counter + 4] + "," + line_el[csv_counter + 5] + "\n")

                    # print(player_info)

                    output_text.write(player_info)

        global converted_to_txt
        converted_to_txt = full_name

        if mode == "w":
            result = "Player data from {} transferred to {} successfully!\n".format(csv_full_file_name, full_name)
        elif mode == "a":
            result = "Player data from {} added to {} successfully!\n".format(csv_full_file_name, full_name)

    return result


def is_empty(txt_file):
    """
    Check if a txt file is empty
    """
    with open(txt_file, "r") as player_data_content:
        content = player_data_content.read()
        if content == "":
            return True
        return False


def does_end_with_newline(txt_file):
    """
    If an existing file does not end with a newline return False, else return True.
    """
    with open(txt_file, "r") as player_data_newline:
        last_line = (list(player_data_newline)[-1])

        if last_line[-1:] == '\n':
            return True
        else:
            return False


def add_newline(txt_file):
    """
    If end_with_newline() == False, add one newline.
    """
    with open(txt_file, "a") as player_data_newline:
        if not does_end_with_newline(txt_file):
            player_data_newline.write('\n')


def end_with_multiple_newline(txt_file):
    """
    If it ends with multiple newlines, leave one newline.
    """
    found_char = False
    char_counter = -1
    with open(txt_file, "r") as player_data_newline:
        newline_data = player_data_newline.read()

        while not found_char:
            if newline_data[char_counter - 1: char_counter] == "\n":
                char_counter -= 1
            else:
                found_char = True

    if char_counter != -1:
        with open(txt_file, "w") as player_data_newline:
            # NEWLINE_COUNT = abs(char_counter)
            newline_data = newline_data[:char_counter + 1]
            player_data_newline.write(newline_data)


def is_output_wanted():
    """
    Ask if user wants a text output .
    """
    ask_output_text_bool = input('Write the results to a text file? (yes or no): ')
    while True:
        if ask_output_text_bool.lower() == 'yes':
            return True
        elif ask_output_text_bool.lower() == 'no':
            return False
        else:
            print('Invalid input!')
            ask_output_text_bool = input('Write the results to a text file? (yes or no): ')


def take_output_name():
    """
    Get output text file name.
    """
    output_text_name = input("Enter a file name to output team data (Ex: 'output'): ")
    output_text_fullname = output_text_name + ".txt"
    print("'{}' will be created/opened and team data will be written on it.\n"
          .format(output_text_fullname))
    return output_text_fullname


def find_from_mail(p_dict, inp):
    """
    Find player data by mail.
    """
    result = ""
    for key in p_dict:
        if inp in key.lower():
            result += "{:30s} --> {}\n".format(key, p_dict[key])
    if result != "":
        return result
    else:
        return "This Mail Does Not Exist In The List!\n"


def find_from_nick(p_dict, inp):
    """
    Find player data by nick.
    """
    result = ""
    for key in p_dict:
        if inp in p_dict[key][0].lower():
            result += "{:30s} --> {}\n".format(key, p_dict[key])
    if result != "":
        return result
    else:
        return "This Nick Does Not Exist In The List!\n"


def find_from_fullname(p_dict, inp):
    """
    Find player data by fullname.
    """
    result = ""
    for key in p_dict:
        if inp in p_dict[key][1].lower():
            result += "{:30s} --> {}\n".format(key, p_dict[key])
    if result != "":
        return result
    else:
        return "This Name Does Not Exist In The List!\n"


def find_from_primary(p_dict, inp):
    """
    Find player data by primary role.
    """
    result = ""
    if inp.lower() != "top" and inp.lower() != "jg" and inp.lower() != "mid" and inp.lower() != "adc" \
            and inp.lower() != "sup":
        return "This Role Does Not Exist!\n"

    for key in p_dict:
        if inp.lower() == p_dict[key][3].lower():
            result += "{:30s} --> {}\n".format(key, p_dict[key])
    if result != "":
        return result
    else:
        return "There are no players with this primary role!\n"


def find_from_secondary(p_dict, inp):
    """
    Find player data by secondary role.
    """
    result = ""
    if inp.lower() != "top" and inp.lower() != "jg" and inp.lower() != "mid" and inp.lower() != "adc" \
            and inp.lower() != "sup":
        return "This Role Does Not Exist!\n"

    for key in p_dict:
        if inp.lower() == p_dict[key][4].lower():
            result += "{:30s} --> {}\n".format(key, p_dict[key])
    if result != "":
        return result
    else:
        return "There are no players with this secondary role!\n"


def change_mail(txt_file, old, new):
    """
    Change player mail.
    """
    result = ""
    with open(txt_file, "r") as ch_mail:
        mail_data = ch_mail.read()
        if old in mail_data:
            mail_data = mail_data.replace(old, new)
            result += "The old mail: '{}' changed to the new mail: '{}'\n".format(old, new)
        else:
            return "There is no player with this old mail!\n"

    with open(txt_file, "w") as ch_mail:
        ch_mail.write(mail_data)

    return result


print(modes)
print(menu)

full_file_name = ""
txt_or_csv = input("Start with txt or csv file? ")
txt_or_csv = txt_or_csv.lower()

# Beginning TXT or CSV question
while txt_or_csv != 'quit':
    if txt_or_csv.strip() == "txt":
        full_file_name = convert_to_type_fullname("txt")
        break

    elif txt_or_csv.strip() == "csv":

        csv_add_create = input(
            "Create a new text file or add information to an existing text file?('create' or 'add') ")
        while csv_add_create != "quit":
            if csv_add_create.lower() == "create":
                print()
                print(convert_csv_to_txt("w"))
                full_file_name = converted_to_txt
                break

            elif csv_add_create.lower() == "add":
                print()
                print(convert_csv_to_txt("a"))
                full_file_name = converted_to_txt
                break

            else:
                print('Invalid input type!\n')
                csv_add_create = input("Create a new text file or add information to an existing text file? ")
        break

    else:
        print('Invalid input type!\n')
        txt_or_csv = input("Start with txt or csv file? ")
        txt_or_csv = txt_or_csv.lower()

# If beginning TXT or CSV question is QUIT
main_loop_inp = ""
first_time = True
if txt_or_csv == 'quit':
    main_loop_inp = 'quit'

# Main While Loop
while main_loop_inp != 'quit':

    # Primary Role Lists
    top, jg, mid, adc, sup = [], [], [], [], []
    # Secondary Role Lists
    sec_top, sec_jg, sec_mid, sec_adc, sec_sup = [], [], [], [], []
    # Primary Role Lists With Ranks
    rank_top, rank_jg, rank_mid, rank_adc, rank_sup = [0], [0], [0], [0], [0]
    # Secondary Role Lists With Ranks
    rank_sec_top, rank_sec_jg, rank_sec_mid, rank_sec_adc, rank_sec_sup = [0], [0], [0], [0], [0]

    if main_loop_inp.strip() == 'txt':
        full_file_name = convert_to_type_fullname("txt")

    # Create TXT File with new name if there is none
    try:
        with open(full_file_name, "r") as player_data:
            pass
    except FileNotFoundError:
        with open(full_file_name, "w") as player_data:
            pass

    # Check if file is empty and Make Sure TXT ends with \n in an old file
    if not is_empty(full_file_name):
        if does_end_with_newline(full_file_name):
            end_with_multiple_newline(full_file_name)
        else:
            add_newline(full_file_name)

    # Read Data
    with open(full_file_name, "r") as player_data_read:

        rank_point = 0
        player_dict = {}
        data = ""

        for line in player_data_read:
            # Create Player Dictionary
            data = line.strip().split(",")
            if "@ug.bilkent.edu.tr" in data[0]:
                player_dict[data[0]] = [data[1], data[2], data[3], data[4], data[5]]

                # Append to Primary Roles
                if player_dict[data[0]][3].lower() == 'top':
                    top.append(data[0])
                elif player_dict[data[0]][3].lower() == 'jg':
                    jg.append(data[0])
                elif player_dict[data[0]][3].lower() == 'mid':
                    mid.append(data[0])
                elif player_dict[data[0]][3].lower() == 'adc':
                    adc.append(data[0])
                elif player_dict[data[0]][3].lower() == 'sup':
                    sup.append(data[0])

                # Append to Secondary Roles
                if player_dict[data[0]][4].lower() == 'top':
                    sec_top.append(data[0])
                elif player_dict[data[0]][4].lower() == 'jg':
                    sec_jg.append(data[0])
                elif player_dict[data[0]][4].lower() == 'mid':
                    sec_mid.append(data[0])
                elif player_dict[data[0]][4].lower() == 'adc':
                    sec_adc.append(data[0])
                elif player_dict[data[0]][4].lower() == 'sup':
                    sec_sup.append(data[0])

                # Calculate Rank
                if player_dict[data[0]][2].lower() == 'iron':
                    rank_point = 1
                elif player_dict[data[0]][2].lower() == 'bronze':
                    rank_point = 2
                elif player_dict[data[0]][2].lower() == 'silver':
                    rank_point = 3
                elif player_dict[data[0]][2].lower() == 'gold':
                    rank_point = 4
                elif player_dict[data[0]][2].lower() == 'platinum':
                    rank_point = 5
                elif player_dict[data[0]][2].lower() == 'diamond':
                    rank_point = 6
                elif player_dict[data[0]][2].lower() == 'master':
                    rank_point = 7
                elif player_dict[data[0]][2].lower() == 'grandmaster':
                    rank_point = 8
                elif player_dict[data[0]][2].lower() == 'challenger':
                    rank_point = 9

                # Append To Rank Primary
                if player_dict[data[0]][3].lower() == 'top':
                    rank_top.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][3].lower() == 'jg':
                    rank_jg.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][3].lower() == 'mid':
                    rank_mid.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][3].lower() == 'adc':
                    rank_adc.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][3].lower() == 'sup':
                    rank_sup.append(data[0] + " " + str(rank_point))

                # Append To Rank Secondary
                if player_dict[data[0]][4].lower() == 'top':
                    rank_sec_top.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][4].lower() == 'jg':
                    rank_sec_jg.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][4].lower() == 'mid':
                    rank_sec_mid.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][4].lower() == 'adc':
                    rank_sec_adc.append(data[0] + " " + str(rank_point))
                elif player_dict[data[0]][4].lower() == 'sup':
                    rank_sec_sup.append(data[0] + " " + str(rank_point))

        # print(player_dict)
        # print()
        # print(top, jg, mid, adc, sup)
        # print(sec_top, sec_jg, sec_mid, sec_adc, sec_sup)
        # print(rank_top, rank_jg, rank_mid, rank_adc, rank_sup)
        # print(rank_sec_top, rank_sec_jg, rank_sec_mid, rank_sec_adc, rank_sec_sup)

    # Menu
    if main_loop_inp.strip() == 'menu':
        print(menu)

    # Modes
    if main_loop_inp.strip() == 'modes':
        print(modes)

    # Ask for additional input
    if main_loop_inp.strip() == 'add':

        with open(full_file_name, "a") as player_data:

            print(add_info)
            addition = input("Add Player Data(Type 'stop' to stop inputting): ")

            while addition.lower() != "stop":

                usr_info = addition.split(",")

                # Input Validation
                # Data length has to be 6
                if not 5 < len(usr_info) < 7:
                    print('Invalid Player Data!\n')

                # Email has to contain "@ug.bilkent.edu.tr"
                elif "@ug.bilkent.edu.tr" not in usr_info[0]:
                    print('Invalid Player Mail! Not a Bilkent Mail!\n')

                # Primary Role Inputs
                elif not (usr_info[4].lower() == 'top' or
                          usr_info[4].lower() == 'jg' or
                          usr_info[4].lower() == 'mid' or
                          usr_info[4].lower() == 'adc' or
                          usr_info[4].lower() == 'sup'):
                    print('Invalid Player Primary Role!\n')

                # Secondary Role Inputs
                elif not (usr_info[5].lower() == 'top' or
                          usr_info[5].lower() == 'jg' or
                          usr_info[5].lower() == 'mid' or
                          usr_info[5].lower() == 'adc' or
                          usr_info[5].lower() == 'sup'):
                    print('Invalid Player Secondary Role!\n')

                # Look for same mails
                elif usr_info[0] in player_dict.keys():
                    print('Invalid Player Mail! This Player Is Already On The List!\n')

                # Add to txt
                else:
                    # Mail Can Not have spaces
                    if " " in usr_info[0]:
                        usr_info[0] = usr_info[0].replace(" ", "_")

                    # Nick Can Not have spaces
                    if " " in usr_info[1]:
                        usr_info[1] = usr_info[1].replace(" ", "_")

                    # Fullname Can Not have spaces
                    if " " in usr_info[2]:
                        usr_info[2] = usr_info[2].replace(" ", "_")

                    print("--> Player Added!\n")
                    player_data.write("{},{},{},{},{},{}\n".format(usr_info[0], usr_info[1], usr_info[2],
                                                                   usr_info[3], usr_info[4], usr_info[5]))

                addition = input("Add Player Data(Type 'stop' to stop inputting): ")

        print('')

    # See TXT File RAW
    elif main_loop_inp.strip() == 'see':
        print(raw_print(full_file_name))

    # See TXT File Numbered
    elif main_loop_inp.strip() == 'number':
        print(numbered_print(full_file_name))

    # See TXT File Numbered WITH Bilkent Mails
    elif main_loop_inp.strip() == 'bilkent number':
        print(bilkent_numbered_print(full_file_name))

    # Find From Mail
    elif main_loop_inp.strip() == 'mail':
        mail = input("Enter keywords to look for in the player mail: ")
        print(find_from_mail(player_dict, mail))

    # Find From Nick
    elif main_loop_inp.strip() == 'nick':
        nick = input("Enter keywords to look for in the player nick: ")
        print(find_from_nick(player_dict, nick))

    # Find From Fullname
    elif main_loop_inp.strip() == 'fullname':
        fullname = input("Enter keywords to look for in the player fullname: ")
        print(find_from_fullname(player_dict, fullname))

    # Find From Primary Role
    elif main_loop_inp.strip() == 'primary':
        primary = input("Enter primary role to look for: ")
        print(find_from_primary(player_dict, primary))

    # Find From Secondary Role
    elif main_loop_inp.strip() == 'secondary':
        secondary = input("Enter secondary role to look for: ")
        print(find_from_secondary(player_dict, secondary))

    # Change Player Mail
    elif main_loop_inp.strip() == 'change mail':
        old_mail = input("Enter the old mail of the player: ")
        new_mail = input("Enter the new mail of the player: ")
        print(change_mail(full_file_name, old_mail, new_mail))

    # TXT Input
    elif main_loop_inp.strip() == 'txt':
        pass

    # CSV File
    elif main_loop_inp.strip() == 'csv':

        csv_file_fullname = convert_to_type_fullname("csv")

        csv_file = open(csv_file_fullname, "r")
        csv_reader = csv.reader(csv_file)

        next(csv_reader)

        csv_add_create = input(
            "Create a new text file or add information to an existing text file?('create' or 'add') ")
        while csv_add_create != "quit":
            if csv_add_create.lower() == "create":
                print(convert_csv_to_txt("w"))
                break

            elif csv_add_create.lower() == "add":
                print(convert_csv_to_txt("a"))
                break

            else:
                print('Invalid input type!')
                csv_add_create = input("Create a new text file or add information to an existing text file? ")
        break

    # Deleting players
    elif main_loop_inp.strip() == 'del':
        with open(full_file_name, "r") as delete_players:
            temp_list = []
            del_list = []

            del_pl = input("Enter player numbers to delete, separated by spaces: ")
            for j in del_pl.split():
                del_list.append(j)
            del_list.sort(reverse=True)

            for line in delete_players:
                temp_list.append(line.strip())

            for i in del_list:
                try:
                    temp_list.pop(int(i) - 1)
                except IndexError:
                    print('There is no player with number {}'.format(i))

        with open(full_file_name, "w") as new_file:
            for k in temp_list:
                new_file.write(k + '\n')

    # Create Teams Primary
    elif main_loop_inp.strip() == 'start p':

        result_text = ""
        max_team_num = min(len(top), len(jg), len(mid), len(adc), len(sup))

        result_text += "\n" + 'Max team number is ' + str(max_team_num) + "\n\n"

        for num in range(1, max_team_num + 1):
            # t = random.randint(0, len(top) - 1)
            t = random.randint(0, len(top) - 1) if len(top) > 1 else 0
            j = random.randint(0, len(jg) - 1) if len(jg) > 1 else 0
            m = random.randint(0, len(mid) - 1) if len(mid) > 1 else 0
            a = random.randint(0, len(adc) - 1) if len(adc) > 1 else 0
            s = random.randint(0, len(sup) - 1) if len(sup) > 1 else 0

            display_top = "{:18s} --> {:25s} - {}".format(player_dict[top[t]][0], player_dict[top[t]][1], top[t])
            display_jg = "{:18s} --> {:25s} - {}".format(player_dict[jg[j]][0], player_dict[jg[j]][1], jg[j])
            display_mid = "{:18s} --> {:25s} - {}".format(player_dict[mid[m]][0], player_dict[mid[m]][1], mid[m])
            display_adc = "{:18s} --> {:25s} - {}".format(player_dict[adc[a]][0], player_dict[adc[a]][1], adc[a])
            display_sup = "{:18s} --> {:25s} - {}".format(player_dict[sup[s]][0], player_dict[sup[s]][1], sup[s])

            result_text += "Team {}\nTop    : {}\nJg     : {}\nMid    : {}\nADC    : {}\nSup    : {} \n\n"\
                .format(num, display_top, display_jg, display_mid, display_adc, display_sup)

            top.pop(t)
            jg.pop(j)
            mid.pop(m)
            adc.pop(a)
            sup.pop(s)

        result_text += "Left Players: \n"

        # Number of roles
        number_of_top, number_of_jg, number_of_mid, number_of_adc, number_of_sup = 0, 0, 0, 0, 0
        for top in top:
            leftover_top = "{:18s} --> {:25s} - {}".format(player_dict[top][0], player_dict[top][1], top)
            result_text += "Top    : {}\n".format(leftover_top)
            number_of_top += 1
        for jg in jg:
            leftover_jg = "{:18s} --> {:25s} - {}".format(player_dict[jg][0], player_dict[jg][1], jg)
            result_text += "Jg     : {}\n".format(leftover_jg)
            number_of_jg += 1
        for mid in mid:
            leftover_mid = "{:18s} --> {:25s} - {}".format(player_dict[mid][0], player_dict[mid][1], mid)
            result_text += "Mid    : {}\n".format(leftover_mid)
            number_of_mid += 1
        for adc in adc:
            leftover_adc = "{:18s} --> {:25s} - {}".format(player_dict[adc][0], player_dict[adc][1], adc)
            result_text += "ADC    : {}\n".format(leftover_adc)
            number_of_adc += 1
        for sup in sup:
            leftover_sup = "{:18s} --> {:25s} - {}".format(player_dict[sup][0], player_dict[sup][1], sup)
            result_text += "Sup    : {}\n".format(leftover_sup)
            number_of_sup += 1

        # Number of Remaining Roles to Create Perfect Teams
        potential_max = max(number_of_top, number_of_jg, number_of_mid, number_of_adc, number_of_sup)
        remaining_top, remaining_jg, remaining_mid, remaining_adc, remaining_sup = potential_max - number_of_top, \
            potential_max - number_of_jg, potential_max - number_of_mid, potential_max - number_of_adc, \
            potential_max - number_of_sup

        if (number_of_top and number_of_jg and number_of_mid and number_of_adc and number_of_sup) == 0:

            result_text += "\n{} Top, {} Jungle, {} Mid, {} ADC, {} Support players are not in a team.\n".format(
                number_of_top, number_of_jg, number_of_mid, number_of_adc, number_of_sup)

            result_text += "\n{} Top, {} Jungle, {} Mid, {} ADC, {} Support players are needed to create perfect " \
                           "amount of teams.\n".format(remaining_top, remaining_jg, remaining_mid,
                                                       remaining_adc, remaining_sup)

            result_text += 'NO Auto-Fills! NO Secondary Roles! NO Ranks!\nAll players are in their primary roles!'

        else:
            result_text += "\nNo leftover players.\nNo Auto-Fills! All players are in their primary roles!"

        print(result_text)
        print('')

        if is_output_wanted():
            output_file_name = take_output_name()
            with open(output_file_name, "w") as result_output_file:
                result_output_file.write(result_text)
        else:
            print('No output file.\n')

    # Create Teams Primary AutoFill
    elif main_loop_inp == 'start pa':

        result_text = ""
        max_team_num_w_af = (len(top) + len(jg) + len(mid) + len(adc) + len(sup)) // 5

        number_of_top, number_of_jg, number_of_mid, number_of_adc, number_of_sup = len(top), len(jg), len(mid), \
            len(adc), len(sup)
        remaining_top, remaining_jg, remaining_mid, remaining_adc, remaining_sup = 0, 0, 0, 0, 0
        fit_top, fit_jg, fit_mid, fit_adc, fit_sup = 0, 0, 0, 0, 0

        # Fit number of roles // Number of Remaining additional roles
        if number_of_top >= max_team_num_w_af:
            fit_top = max_team_num_w_af
            remaining_top = number_of_top - fit_top
        else:
            fit_top = number_of_top
            remaining_top = 0

        if number_of_jg >= max_team_num_w_af:
            fit_jg = max_team_num_w_af
            remaining_jg = number_of_jg - fit_jg
        else:
            fit_jg = number_of_jg
            remaining_jg = 0

        if number_of_mid >= max_team_num_w_af:
            fit_mid = max_team_num_w_af
            remaining_mid = number_of_mid - fit_mid
        else:
            fit_mid = number_of_mid
            remaining_mid = 0

        if number_of_adc >= max_team_num_w_af:
            fit_adc = max_team_num_w_af
            remaining_adc = number_of_adc - fit_adc
        else:
            fit_adc = number_of_adc
            remaining_adc = 0

        if number_of_sup >= max_team_num_w_af:
            fit_sup = max_team_num_w_af
            remaining_sup = number_of_sup - fit_sup
        else:
            fit_sup = number_of_sup
            remaining_sup = 0

        players_on_role = fit_top + fit_jg + fit_mid + fit_adc + fit_sup
        players_auto_filled = max_team_num_w_af * 5 - players_on_role
        auto_fills_for_each_game = players_auto_filled / max_team_num_w_af
        out_of_game = remaining_top + remaining_jg + remaining_mid + remaining_adc + remaining_sup - players_auto_filled

        # print(number_of_top, number_of_jg, number_of_mid, number_of_adc, number_of_sup)
        # print(fit_top, fit_jg, fit_mid, fit_adc, fit_sup)
        # print(remaining_top, remaining_jg, remaining_mid, remaining_adc, remaining_sup)

        result_text += "\nMax team number with auto-fills is " + str(max_team_num_w_af) + "\n{} players on role, {} " \
                       "players auto-filled, and {} players out of game\n".format(players_on_role, players_auto_filled,
                                                                                  out_of_game)

        af_floor = math.floor(auto_fills_for_each_game)
        af_ceil = math.ceil(auto_fills_for_each_game)

        if players_auto_filled % max_team_num_w_af == 0:
            result_text += "{} auto-filled players for each team\n\n".format(int(auto_fills_for_each_game))
        else:
            result_text += "{} or {} auto-filled players for each team\n\n".format(af_floor, af_ceil)

        auto_fill_list = []

        print(top, jg, mid, adc, sup)

        if remaining_top != 0:
            for i in range(remaining_top):
                t = random.randint(0, len(top) - 1) if len(top) > 1 else 0
                auto_fill_list.append(top[t])
                top.pop(t)
        if remaining_jg != 0:
            for i in range(remaining_jg):
                j = random.randint(0, len(jg) - 1) if len(jg) > 1 else 0
                auto_fill_list.append(jg[j])
                jg.pop(j)
        if remaining_mid != 0:
            for i in range(remaining_mid):
                m = random.randint(0, len(mid) - 1) if len(mid) > 1 else 0
                auto_fill_list.append(mid[m])
                mid.pop(m)
        if remaining_adc != 0:
            for i in range(remaining_adc):
                a = random.randint(0, len(adc) - 1) if len(adc) > 1 else 0
                auto_fill_list.append(adc[a])
                adc.pop(a)
        if remaining_sup != 0:
            for i in range(remaining_sup):
                s = random.randint(0, len(sup) - 1) if len(sup) > 1 else 0
                auto_fill_list.append(sup[s])
                sup.pop(s)

        team_number = max_team_num_w_af
        teams = [[0] for i in range(max_team_num_w_af)]

        # print(top, jg, mid, adc, sup)
        # print(auto_fill_list)
        # print(teams)
        # print('')

        # Role numbers
        fix_top, fix_jg, fix_mid, fix_adc, fix_sup = 1, 2, 3, 4, 5

        # First available list
        first_available = 0
        for i in range(max_team_num_w_af):
            if teams[i][0] < af_ceil:
                first_available = i
                break

        # Top AutoFill
        if max_team_num_w_af == fit_top:
            for i in range(max_team_num_w_af):
                rand_num = random.randint(0, len(top) - 1)
                teams[i].append(top[rand_num])
                top.pop(rand_num)
        elif max_team_num_w_af > fit_top:
            for i in range(first_available, first_available + max_team_num_w_af - fit_top):
                if teams[i][0] < af_ceil:
                    rand_num = random.randint(0, len(auto_fill_list) - 1)
                    teams[i].append(auto_fill_list[rand_num])
                    teams[i][0] = teams[i][0] + 1
                    auto_fill_list.pop(rand_num)
            for j in range(max_team_num_w_af):
                try:
                    hello = teams[j][fix_top]
                except IndexError:
                    rand_num = random.randint(0, len(top) - 1)
                    teams[j].append(top[rand_num])
                    top.pop(rand_num)

        # First available list
        for i in range(max_team_num_w_af):
            if teams[i][0] < af_ceil:
                first_available = i
                break

        # Jungle AutoFill
        if max_team_num_w_af == fit_jg:
            for i in range(max_team_num_w_af):
                rand_num = random.randint(0, len(jg) - 1)
                teams[i].append(jg[rand_num])
                jg.pop(rand_num)
        elif max_team_num_w_af > fit_jg:
            for i in range(first_available, first_available + max_team_num_w_af - fit_jg):
                if teams[i][0] < af_ceil:
                    rand_num = random.randint(0, len(auto_fill_list) - 1)
                    teams[i].append(auto_fill_list[rand_num])
                    teams[i][0] = teams[i][0] + 1
                    auto_fill_list.pop(rand_num)
            for j in range(max_team_num_w_af):
                try:
                    hello = teams[j][fix_jg]
                except IndexError:
                    rand_num = random.randint(0, len(jg) - 1)
                    teams[j].append(jg[rand_num])
                    jg.pop(rand_num)

        # First available list
        for i in range(max_team_num_w_af):
            if teams[i][0] < af_ceil:
                first_available = i
                break

        # Middle AutoFill
        if max_team_num_w_af == fit_mid:
            for i in range(max_team_num_w_af):
                rand_num = random.randint(0, len(mid) - 1)
                teams[i].append(mid[rand_num])
                mid.pop(rand_num)
        elif max_team_num_w_af > fit_mid:
            for i in range(first_available, first_available + max_team_num_w_af - fit_mid):
                if teams[i][0] < af_ceil:
                    rand_num = random.randint(0, len(auto_fill_list) - 1)
                    teams[i].append(auto_fill_list[rand_num])
                    teams[i][0] = teams[i][0] + 1
                    auto_fill_list.pop(rand_num)
            for j in range(max_team_num_w_af):
                try:
                    hello = teams[j][fix_mid]
                except IndexError:
                    rand_num = random.randint(0, len(mid) - 1)
                    teams[j].append(mid[rand_num])
                    mid.pop(rand_num)

        # First available list
        for i in range(max_team_num_w_af):
            if teams[i][0] < af_ceil:
                first_available = i
                break

        # ADC AutoFill
        if max_team_num_w_af == fit_adc:
            for i in range(max_team_num_w_af):
                rand_num = random.randint(0, len(adc) - 1)
                teams[i].append(adc[rand_num])
                adc.pop(rand_num)
        elif max_team_num_w_af > fit_adc:
            for i in range(first_available, first_available + max_team_num_w_af - fit_adc):
                if teams[i][0] < af_ceil:
                    rand_num = random.randint(0, len(auto_fill_list) - 1)
                    teams[i].append(auto_fill_list[rand_num])
                    teams[i][0] = teams[i][0] + 1
                    auto_fill_list.pop(rand_num)
            for j in range(max_team_num_w_af):
                try:
                    hello = teams[j][fix_adc]
                except IndexError:
                    rand_num = random.randint(0, len(adc) - 1)
                    teams[j].append(adc[rand_num])
                    adc.pop(rand_num)

        # First available list
        for i in range(max_team_num_w_af):
            if teams[i][0] < af_ceil:
                first_available = i
                break

        # Support AutoFill
        if max_team_num_w_af == fit_sup:
            for i in range(max_team_num_w_af):
                rand_num = random.randint(0, len(sup) - 1)
                teams[i].append(sup[rand_num])
                sup.pop(rand_num)
        elif max_team_num_w_af > fit_sup:
            for i in range(first_available, first_available + max_team_num_w_af - fit_sup):
                if teams[i][0] < af_ceil:
                    rand_num = random.randint(0, len(auto_fill_list) - 1)
                    teams[i].append(auto_fill_list[rand_num])
                    teams[i][0] = teams[i][0] + 1
                    auto_fill_list.pop(rand_num)
            for j in range(max_team_num_w_af):
                try:
                    hello = teams[j][fix_sup]
                except IndexError:
                    rand_num = random.randint(0, len(sup) - 1)
                    teams[j].append(sup[rand_num])
                    sup.pop(rand_num)

        # print(top, jg, mid, adc, sup)
        # print(teams)
        # print(auto_fill_list)
        # print(max_team_num_w_af)

        for k in range(0, max_team_num_w_af):
            player1, player2, player3, player4, player5 = teams[k][1], teams[k][2], teams[k][3], teams[k][4], \
                                                          teams[k][5]

            nick_disp_top, nick_disp_jg, nick_disp_mid, nick_disp_adc, nick_disp_sup = player_dict[player1][0], player_dict[player2][0], player_dict[player3][0], player_dict[player4][0], player_dict[player5][0]

            if player_dict[player1][3].lower() != 'top':
                nick_disp_top = player_dict[player1][0] + " (Auto-Fill Top)"
            elif player_dict[player2][3].lower() != 'jg':
                nick_disp_jg = player_dict[player2][0] + " (Auto-Fill Jungle)"
            elif player_dict[player3][3].lower() != 'mid':
                nick_disp_mid = player_dict[player3][0] + " (Auto-Fill Mid)"
            elif player_dict[player4][3].lower() != 'adc':
                nick_disp_adc = player_dict[player4][0] + " (Auto-Fill ADC)"
            elif player_dict[player5][3].lower() != 'sup':
                nick_disp_sup = player_dict[player5][0] + " (Auto-Fill Support)"

            display_top = "{:25s} --> {:25s} - {}".format(nick_disp_top, player_dict[player1][1], player1)
            display_jg = "{:25s} --> {:25s} - {}".format(nick_disp_jg, player_dict[player2][1], player2)
            display_mid = "{:25s} --> {:25s} - {}".format(nick_disp_mid, player_dict[player3][1], player3)
            display_adc = "{:25s} --> {:25s} - {}".format(nick_disp_adc, player_dict[player4][1], player4)
            display_sup = "{:25s} --> {:25s} - {}".format(nick_disp_sup, player_dict[player5][1], player5)

            result_text += "Team {}\nTop    : {}\nJg     : {}\nMid    : {}\nADC    : {}\nSup    : {}\n\n"\
                .format(k + 1, display_top, display_jg, display_mid, display_adc, display_sup)

        if len(auto_fill_list) > 0:
            result_text += "Leftover players:\n"
            for keys in auto_fill_list:
                if player_dict[keys][3].lower() == "top":
                    leftover_top = "{:18s} --> {:25s} - {}".format(player_dict[keys][0], player_dict[keys][1], keys)
                    result_text += "Top    : {}\n".format(leftover_top)
                elif player_dict[keys][3].lower() == "jg":
                    leftover_jg = "{:18s} --> {:25s} - {}".format(player_dict[keys][0], player_dict[keys][1], keys)
                    result_text += "Jg     : {}\n".format(leftover_jg)
                elif player_dict[keys][3].lower() == "mid":
                    leftover_mid = "{:18s} --> {:25s} - {}".format(player_dict[keys][0], player_dict[keys][1], keys)
                    result_text += "Mid    : {}\n".format(leftover_mid)
                elif player_dict[keys][3].lower() == "adc":
                    leftover_adc = "{:18s} --> {:25s} - {}".format(player_dict[keys][0], player_dict[keys][1], keys)
                    result_text += "ADC    : {}\n".format(leftover_adc)
                elif player_dict[keys][3].lower() == "sup":
                    leftover_sup = "{:18s} --> {:25s} - {}".format(player_dict[keys][0], player_dict[keys][1], keys)
                    result_text += "Sup    : {}\n".format(leftover_sup)

        print(result_text)

        if is_output_wanted():
            output_file_name = take_output_name()
            with open(output_file_name, "w") as result_output_file:
                result_output_file.write(result_text)
        else:
            print('No output file.\n')

    # Create Teams Primary Secondary
    elif main_loop_inp.strip() == 'start ps':
        print("This Module is not available right now!\n")
        pass

    # Create Teams Primary Secondary AutoFill
    elif main_loop_inp.strip() == 'start psa':
        print("This Module is not available right now!\n")
        pass

    # Create Teams Primary Ranked
    elif main_loop_inp == 'start pr':

        # print(rank_top, rank_jg, rank_mid, rank_adc, rank_sup)
        additional_top, additional_jg, additional_mid, additional_adc, additional_sup = [], [], [], [], []

        rank_player_sum = len(rank_top) + len(rank_jg) + len(rank_mid) + len(rank_adc) + len(rank_sup) - 5

        print('')

        tolerance = input("Enter a tolerance level between 0-4 (DEFAULT/RECOMMENDED: 2)(Type 'no' to use default): ")
        while tolerance != "no":
            if tolerance == "0":
                break
            elif tolerance == "1":
                break
            elif tolerance == "2":
                break

            elif tolerance == "3":
                break
            elif tolerance == "4":
                break
            else:
                print("Tolerance number not within boundaries!")
                tolerance = input("Enter a tolerance level between 0-4 (DEFAULT/RECOMMENDED: 2)"
                                  "(Type 'no' to use default): ")

        if tolerance == "no":
            tolerance = 2

        tolerance = int(tolerance)

        result_text = ""

        max_team_num = min(len(rank_top), len(rank_jg), len(rank_mid), len(rank_adc), len(rank_sup))
        max_team_num -= 1
        max_player_num = len(rank_top) + len(rank_jg) + len(rank_mid) + len(rank_adc) + len(rank_sup) - 5

        result_text += "\nMax team number is {}\n\n".format(max_team_num)

        # Get Rid Of Additional Players
        if len(rank_top) > max_team_num:
            for num in range(len(rank_top) - max_team_num - 1):
                t = random.randint(1, len(rank_top) - 1) if len(rank_top) > 2 else 1
                additional_top.append(rank_top[t])
                rank_top.pop(t)
        if len(rank_jg) > max_team_num:
            for num in range(len(rank_jg) - max_team_num - 1):
                j = random.randint(1, len(rank_jg) - 1) if len(rank_jg) > 2 else 1
                additional_jg.append(rank_jg[j])
                rank_jg.pop(j)
        if len(rank_mid) > max_team_num:
            for num in range(len(rank_mid) - max_team_num - 1):
                m = random.randint(1, len(rank_mid) - 1) if len(rank_mid) > 2 else 1
                additional_mid.append(rank_mid[m])
                rank_mid.pop(m)
        if len(rank_adc) > max_team_num:
            for num in range(len(rank_adc) - max_team_num - 1):
                a = random.randint(1, len(rank_adc) - 1) if len(rank_adc) > 2 else 1
                additional_adc.append(rank_adc[a])
                rank_adc.pop(a)
        if len(rank_sup) > max_team_num:
            for num in range(len(rank_sup) - max_team_num - 1):
                s = random.randint(1, len(rank_sup) - 1) if len(rank_sup) > 2 else 1
                additional_sup.append(rank_sup[s])
                rank_sup.pop(s)

        # Sum of all Rank points
        sum_rank = 0
        for i in range(1, max_team_num + 1):
            rank_top[0] += int(rank_top[i][-1:])
            rank_jg[0] += int(rank_jg[i][-1:])
            rank_mid[0] += int(rank_mid[i][-1:])
            rank_adc[0] += int(rank_adc[i][-1:])
            rank_sup[0] += int(rank_sup[i][-1:])

        sum_rank = rank_top[0] + rank_jg[0] + rank_mid[0] + rank_adc[0] + rank_sup[0]
        all_player_list = [rank_top, rank_jg, rank_mid, rank_adc, rank_sup]
        avg_rank_per_team = sum_rank / max_team_num

        # tolerance = 2 DEFAULT TOLERANCE
        # print(sum_rank, avg_rank_per_team, tolerance)
        # print(rank_top, rank_jg, rank_mid, rank_adc, rank_sup)

        teams = [[0] for i in range(max_team_num)]

        found_team = False
        no_possible_count = 0
        max_loop_count = 20
        no_possible_teams = True

        # Main Ranked Loop
        while no_possible_teams and no_possible_count < max_loop_count:

            shuffle_top, shuffle_jg, shuffle_mid, shuffle_adc, shuffle_sup = rank_top[:], rank_jg[:], \
                                                                             rank_mid[:], rank_adc[:], rank_sup[:]

            teams = [[0] for i in range(max_team_num)]
            temp_all_player_list = [shuffle_top, shuffle_jg, shuffle_mid, shuffle_adc, shuffle_sup]
            found_team_count = 0
            left_team_number = max_team_num

            # print(all_player_list)
            # print(temp_all_player_list)
            # print('before for')
            # print()

            no_possible_teams = False

            for k in range(5):
                temp_rank = temp_all_player_list[k][0]
                temp_all_player_list[k].pop(0)
                random.shuffle(temp_all_player_list[k])
                temp_all_player_list[k].insert(0, temp_rank)
                # print(temp_all_player_list[k], temp_rank)

            # print()

            # print('all player')
            # print(all_player_list)
            # print('temp player')
            # print(temp_all_player_list)
            # print()

            no_possible_count += 1
            # print(no_possible_count)
            # print()

            while (found_team_count != max_team_num) and (not no_possible_teams):
                found_team = False
                top_player_counter, jg_player_counter, mid_player_counter, \
                    adc_player_counter, sup_player_counter = 1, 1, 1, 1, 1

                while not found_team and not no_possible_teams:
                    current_rank_sum = 0
                    current_rank_sum += int(temp_all_player_list[0][top_player_counter][-1:]) + \
                        int(temp_all_player_list[1][jg_player_counter][-1:]) + \
                        int(temp_all_player_list[2][mid_player_counter][-1:]) + \
                        int(temp_all_player_list[3][adc_player_counter][-1:]) + \
                        int(temp_all_player_list[4][sup_player_counter][-1:])

                    # print(current_rank_sum)
                    # print(temp_all_player_list)
                    # print(teams)

                    if avg_rank_per_team - tolerance <= current_rank_sum <= avg_rank_per_team + tolerance:
                        found_team = True
                        found_team_count += 1
                        left_team_number -= 1

                        temp_all_player_list[0][0] -= int(temp_all_player_list[0][top_player_counter][-1:])
                        teams[found_team_count - 1].append(temp_all_player_list[0][top_player_counter])
                        teams[found_team_count - 1][0] += int(temp_all_player_list[0][top_player_counter][-1:])
                        temp_all_player_list[0].pop(top_player_counter)

                        temp_all_player_list[1][0] -= int(temp_all_player_list[1][jg_player_counter][-1:])
                        teams[found_team_count - 1].append(temp_all_player_list[1][jg_player_counter])
                        teams[found_team_count - 1][0] += int(temp_all_player_list[1][jg_player_counter][-1:])
                        temp_all_player_list[1].pop(jg_player_counter)

                        temp_all_player_list[2][0] -= int(temp_all_player_list[2][mid_player_counter][-1:])
                        teams[found_team_count - 1].append(temp_all_player_list[2][mid_player_counter])
                        teams[found_team_count - 1][0] += int(temp_all_player_list[2][mid_player_counter][-1:])
                        temp_all_player_list[2].pop(mid_player_counter)

                        temp_all_player_list[3][0] -= int(temp_all_player_list[3][adc_player_counter][-1:])
                        teams[found_team_count - 1].append(temp_all_player_list[3][adc_player_counter])
                        teams[found_team_count - 1][0] += int(temp_all_player_list[3][adc_player_counter][-1:])
                        temp_all_player_list[3].pop(adc_player_counter)

                        temp_all_player_list[4][0] -= int(temp_all_player_list[4][sup_player_counter][-1:])
                        teams[found_team_count - 1].append(temp_all_player_list[4][sup_player_counter])
                        teams[found_team_count - 1][0] += int(temp_all_player_list[4][sup_player_counter][-1:])
                        temp_all_player_list[4].pop(sup_player_counter)

                        # print('found team')

                    else:
                        # print('not found')
                        if top_player_counter == 1 and jg_player_counter == 1 and mid_player_counter == 1 and \
                                adc_player_counter == 1 and sup_player_counter == 1 and \
                                max_team_num - found_team_count == 1:
                            # print('no condition')
                            no_possible_teams = True

                        elif sup_player_counter != left_team_number:
                            sup_player_counter += 1

                        elif adc_player_counter < left_team_number < sup_player_counter + 1:
                            adc_player_counter += 1
                            sup_player_counter = 1

                        elif mid_player_counter < left_team_number < adc_player_counter + 1:
                            mid_player_counter += 1
                            adc_player_counter, sup_player_counter = 1, 1

                        elif jg_player_counter < left_team_number < mid_player_counter + 1:
                            jg_player_counter += 1
                            mid_player_counter, adc_player_counter, sup_player_counter = 1, 1, 1

                        elif top_player_counter < left_team_number < jg_player_counter + 1:
                            top_player_counter += 1
                            jg_player_counter, mid_player_counter, adc_player_counter, sup_player_counter = 1, 1, 1, 1

                        elif top_player_counter + 1 > left_team_number:
                            no_possible_teams = True

                    # print(top_player_counter, jg_player_counter, mid_player_counter, adc_player_counter,
                    # sup_player_counter)

                    # print('sleep for 3 seconds')
                    # print('')
                    # time.sleep(3)

                # print(temp_all_player_list)

        # print(teams)
        # print(temp_all_player_list)
        # print(all_player_list)
        # print(rank_top, rank_adc)

        result_text += "Rankings: Iron:1, Bronze:2, Silver:3, Gold:4, Platinum:5,\n"
        result_text += "Diamond:6, Master:7, Grandmaster:8, Challenger:9.\n\n"
        result_text += "Average Rank Points per team: {:.2f}\n".format(avg_rank_per_team)
        result_text += "All teams are within the tolerance number of: ±{}\n\n".format(tolerance)

        if not no_possible_teams:
            result_text += "All players that will be put on a team: \n"

            for top in range(max_team_num):
                display_top = "{:18s} - {} --> {:25s} - {}".format(player_dict[teams[top][1][:-2]][0],
                                                                   teams[top][1][-1:],
                                                                   player_dict[teams[top][1][:-2]][1],
                                                                   teams[top][1][:-2])
                result_text += "Top    : {}\n".format(display_top)
            for jg in range(max_team_num):
                display_jg = "{:18s} - {} --> {:25s} - {}".format(player_dict[teams[jg][2][:-2]][0],
                                                                  teams[jg][2][-1:],
                                                                  player_dict[teams[jg][2][:-2]][1],
                                                                  teams[jg][2][:-2])
                result_text += "Jg     : {}\n".format(display_jg)
            for mid in range(max_team_num):
                display_mid = "{:18s} - {} --> {:25s} - {}".format(player_dict[teams[mid][3][:-2]][0],
                                                                   teams[mid][3][-1:],
                                                                   player_dict[teams[mid][3][:-2]][1],
                                                                   teams[mid][3][:-2])
                result_text += "Mid    : {}\n".format(display_mid)
            for adc in range(max_team_num):
                display_adc = "{:18s} - {} --> {:25s} - {}".format(player_dict[teams[adc][4][:-2]][0],
                                                                   teams[adc][4][-1:],
                                                                   player_dict[teams[adc][4][:-2]][1],
                                                                   teams[adc][4][:-2])
                result_text += "ADC    : {}\n".format(display_adc)
            for sup in range(max_team_num):
                display_sup = "{:18s} - {} --> {:25s} - {}".format(player_dict[teams[sup][5][:-2]][0],
                                                                   teams[sup][5][-1:],
                                                                   player_dict[teams[sup][5][:-2]][1],
                                                                   teams[sup][5][:-2])
                result_text += "Sup    : {}\n".format(display_sup)
            result_text += "\n\n"

            result_text += "All players that will not play: \n"

            # print(additional_top, additional_jg, additional_mid, additional_adc, additional_sup)

            if additional_top:
                for top in additional_top:
                    display_top = "{:18s} - {} --> {:25s} - {}".format(player_dict[top[:-2]][0],
                                                                       top[-1:],
                                                                       player_dict[top[:-2]][1],
                                                                       top[:-2])
                    result_text += "Top    : {}\n".format(display_top)
            if additional_jg:
                for jg in additional_jg:
                    display_jg = "{:18s} - {} --> {:25s} - {}".format(player_dict[jg[:-2]][0],
                                                                      jg[-1:],
                                                                      player_dict[jg[:-2]][1],
                                                                      jg[:-2])
                    result_text += "Jg     : {}\n".format(display_jg)
            if additional_mid:
                for mid in additional_mid:
                    display_mid = "{:18s} - {} --> {:25s} - {}".format(player_dict[mid[:-2]][0],
                                                                       mid[-1:],
                                                                       player_dict[mid[:-2]][1],
                                                                       mid[:-2])
                    result_text += "Mid    : {}\n".format(display_mid)
            if additional_adc:
                for adc in additional_adc:
                    display_adc = "{:18s} - {} --> {:25s} - {}".format(player_dict[adc[:-2]][0],
                                                                       adc[-1:],
                                                                       player_dict[adc[:-2]][1],
                                                                       adc[:-2])
                    result_text += "ADC    : {}\n".format(display_adc)
            if additional_sup:
                for sup in additional_sup:
                    display_sup = "{:18s} - {} --> {:25s} - {}".format(player_dict[sup[:-2]][0],
                                                                       sup[-1:],
                                                                       player_dict[sup[:-2]][1],
                                                                       sup[:-2])
                    result_text += "Sup    : {}\n".format(display_sup)
            result_text += "\n"

        if no_possible_teams:
            result_text += 'Start another queue, program could not find optimal teams!\n'
        else:
            for k in range(max_team_num):

                player1, player2, player3, player4, player5 = teams[k][1], teams[k][2], teams[k][3], teams[k][4], \
                                                              teams[k][5]
                player_list = [player1, player2, player3, player4, player5]
                show_list = []

                # print(player_list)

                for player in player_list:

                    player = "{:18s} {}".format(player_dict[player[:-2]][0], player[-1:])
                    # print(player)

                    if player[-1:] == '1':
                        player = player[:-2] + " Iron"
                    elif player[-1:] == '2':
                        player = player[:-2] + " Bronze"
                    elif player[-1:] == '3':
                        player = player[:-2] + " Silver"
                    elif player[-1:] == '4':
                        player = player[:-2] + " Gold"
                    elif player[-1:] == '5':
                        player = player[:-2] + " Platinum"
                    elif player[-1:] == '6':
                        player = player[:-2] + " Diamond"
                    elif player[-1:] == '7':
                        player = player[:-2] + " Master"
                    elif player[-1:] == '8':
                        player = player[:-2] + " Grandmaster"
                    elif player[-1:] == '9':
                        player = player[:-2] + " Challenger"
                    show_list.append(player)

                # print(show_list)

                result_text += "Team {}\nTop    : {}\nJg     : {}\nMid    : {}\nADC    : {}\n" \
                               "Sup    : {}\nTotal Rank Point    : {}\n\n" \
                    .format(k + 1, show_list[0], show_list[1], show_list[2], show_list[3], show_list[4], teams[k][0])

            result_text += "All {} players are on their primary roles, " \
                           "{} players out of game!\n".format(max_team_num * 5, max_player_num - max_team_num * 5)
            result_text += "NO Auto-Fills! NO Secondary Roles!\n"
            result_text += "Most equal teams are created with respect to tolerances and rankings of the players!\n"

        print(result_text)

        if not no_possible_teams:
            if is_output_wanted():
                output_file_name = take_output_name()
                with open(output_file_name, "w") as result_output_file:
                    result_output_file.write(result_text)
            else:
                print('No output file.\n')

    # Create Teams Primary Secondary Ranked
    elif main_loop_inp.strip() == 'start psr':
        print("This Module is not available right now!\n")
        pass

    # Create Teams Primary Secondary AutoFill Ranked
    elif main_loop_inp.strip() == 'start psar':
        print("This Module is not available right now!\n")
        pass

    # Else
    else:
        if first_time:
            first_time = False
            pass
        else:
            print('Invalid Command!')
            print('')

    main_loop_inp = input('Enter Command: ')
    main_loop_inp = main_loop_inp.lower()

# Program Ends
print('Good Bye!')
time.sleep(2)
